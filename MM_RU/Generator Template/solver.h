/**********************************************
 * This code was generated by ksolve++ v1.0.0 *
 **********************************************/

#ifndef SOLVER_H
#define SOLVER_H

#include <ctime>
#include <stack>
#include "pruning.h"
#include "puzzle.h"

class Solver{
public:
    Solver(Scramble *s){
        scramble = s;
        puzzle = new Puzzle(*(s->state));
    }

    void solve(){
        nodes = 0;
        numSolutions = 0;
        bool solved = false;
        int slackCounter = 0;

        if(EDGES_p_table[puzzle->encode_EDGES_p()] == -1){
            std::cerr << "Found unsolvable piece set: EDGES_p\n";
            return;
        }
        if(CORNERS_p_table[puzzle->encode_CORNERS_p()] == -1){
            std::cerr << "Found unsolvable piece set: CORNERS_p\n";
            return;
        }
        if(CORNERS_o_table[puzzle->encode_CORNERS_o()] == -1){
            std::cerr << "Found unsolvable piece set: CORNERS_o\n";
            return;
        }

        time_t t = clock();
        for(int i=scramble->startDepth; i<=scramble->maxDepth; i++){
            if(solved && slackCounter == scramble->slack) break;
            if(solved) slackCounter++;
            std::cout << "Depth " << i << "\n" << std::flush;
            if(search(i)) solved = true;
            std::cout << "  " << nodes << " nodes visited, " << (float)(clock()-t)/CLOCKS_PER_SEC << "s\n" << std::flush;
        }
    }

    bool search(int depth){
        if(prune(puzzle, depth)){
            return false;
        }

        bool s = false;
        puzzle->move_0_1(); // U
        soln.push(0);
        nodes++;
        if(search_move_0_1(depth-1)) s = true; // U
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(1);
        nodes++;
        if(search_move_0_2(depth-1)) s = true; // U2
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(2);
        nodes++;
        if(search_move_0_3(depth-1)) s = true; // U2'
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(3);
        nodes++;
        if(search_move_0_4(depth-1)) s = true; // U'
        soln.pop();
        puzzle->move_0_1(); // U
        puzzle->move_1_1(); // R
        soln.push(4);
        nodes++;
        if(search_move_1_1(depth-1)) s = true; // R
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(5);
        nodes++;
        if(search_move_1_2(depth-1)) s = true; // R2
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(6);
        nodes++;
        if(search_move_1_3(depth-1)) s = true; // R2'
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(7);
        nodes++;
        if(search_move_1_4(depth-1)) s = true; // R'
        soln.pop();
        puzzle->move_1_1(); // R
        return s;
    }

    bool search_move_0_1(int depth){ // U
        if(numSolutions == scramble->maxSolutions) return true;
        if(depth == 0) return checkSolved();
        if(prune(puzzle, depth)) return false;

        bool s = false;
        puzzle->move_1_1(); // R
        soln.push(4);
        nodes++;
        if(search_move_1_1(depth-1)) s = true; // R
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(5);
        nodes++;
        if(search_move_1_2(depth-1)) s = true; // R2
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(6);
        nodes++;
        if(search_move_1_3(depth-1)) s = true; // R2'
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(7);
        nodes++;
        if(search_move_1_4(depth-1)) s = true; // R'
        soln.pop();
        puzzle->move_1_1(); // R
        return s;
    }

    bool search_move_0_2(int depth){ // U2
        if(numSolutions == scramble->maxSolutions) return true;
        if(depth == 0) return checkSolved();
        if(prune(puzzle, depth)) return false;

        bool s = false;
        puzzle->move_1_1(); // R
        soln.push(4);
        nodes++;
        if(search_move_1_1(depth-1)) s = true; // R
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(5);
        nodes++;
        if(search_move_1_2(depth-1)) s = true; // R2
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(6);
        nodes++;
        if(search_move_1_3(depth-1)) s = true; // R2'
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(7);
        nodes++;
        if(search_move_1_4(depth-1)) s = true; // R'
        soln.pop();
        puzzle->move_1_1(); // R
        return s;
    }

    bool search_move_0_3(int depth){ // U2'
        if(numSolutions == scramble->maxSolutions) return true;
        if(depth == 0) return checkSolved();
        if(prune(puzzle, depth)) return false;

        bool s = false;
        puzzle->move_1_1(); // R
        soln.push(4);
        nodes++;
        if(search_move_1_1(depth-1)) s = true; // R
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(5);
        nodes++;
        if(search_move_1_2(depth-1)) s = true; // R2
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(6);
        nodes++;
        if(search_move_1_3(depth-1)) s = true; // R2'
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(7);
        nodes++;
        if(search_move_1_4(depth-1)) s = true; // R'
        soln.pop();
        puzzle->move_1_1(); // R
        return s;
    }

    bool search_move_0_4(int depth){ // U'
        if(numSolutions == scramble->maxSolutions) return true;
        if(depth == 0) return checkSolved();
        if(prune(puzzle, depth)) return false;

        bool s = false;
        puzzle->move_1_1(); // R
        soln.push(4);
        nodes++;
        if(search_move_1_1(depth-1)) s = true; // R
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(5);
        nodes++;
        if(search_move_1_2(depth-1)) s = true; // R2
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(6);
        nodes++;
        if(search_move_1_3(depth-1)) s = true; // R2'
        soln.pop();
        puzzle->move_1_1(); // R
        soln.push(7);
        nodes++;
        if(search_move_1_4(depth-1)) s = true; // R'
        soln.pop();
        puzzle->move_1_1(); // R
        return s;
    }

    bool search_move_1_1(int depth){ // R
        if(numSolutions == scramble->maxSolutions) return true;
        if(depth == 0) return checkSolved();
        if(prune(puzzle, depth)) return false;

        bool s = false;
        puzzle->move_0_1(); // U
        soln.push(0);
        nodes++;
        if(search_move_0_1(depth-1)) s = true; // U
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(1);
        nodes++;
        if(search_move_0_2(depth-1)) s = true; // U2
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(2);
        nodes++;
        if(search_move_0_3(depth-1)) s = true; // U2'
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(3);
        nodes++;
        if(search_move_0_4(depth-1)) s = true; // U'
        soln.pop();
        puzzle->move_0_1(); // U
        return s;
    }

    bool search_move_1_2(int depth){ // R2
        if(numSolutions == scramble->maxSolutions) return true;
        if(depth == 0) return checkSolved();
        if(prune(puzzle, depth)) return false;

        bool s = false;
        puzzle->move_0_1(); // U
        soln.push(0);
        nodes++;
        if(search_move_0_1(depth-1)) s = true; // U
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(1);
        nodes++;
        if(search_move_0_2(depth-1)) s = true; // U2
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(2);
        nodes++;
        if(search_move_0_3(depth-1)) s = true; // U2'
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(3);
        nodes++;
        if(search_move_0_4(depth-1)) s = true; // U'
        soln.pop();
        puzzle->move_0_1(); // U
        return s;
    }

    bool search_move_1_3(int depth){ // R2'
        if(numSolutions == scramble->maxSolutions) return true;
        if(depth == 0) return checkSolved();
        if(prune(puzzle, depth)) return false;

        bool s = false;
        puzzle->move_0_1(); // U
        soln.push(0);
        nodes++;
        if(search_move_0_1(depth-1)) s = true; // U
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(1);
        nodes++;
        if(search_move_0_2(depth-1)) s = true; // U2
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(2);
        nodes++;
        if(search_move_0_3(depth-1)) s = true; // U2'
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(3);
        nodes++;
        if(search_move_0_4(depth-1)) s = true; // U'
        soln.pop();
        puzzle->move_0_1(); // U
        return s;
    }

    bool search_move_1_4(int depth){ // R'
        if(numSolutions == scramble->maxSolutions) return true;
        if(depth == 0) return checkSolved();
        if(prune(puzzle, depth)) return false;

        bool s = false;
        puzzle->move_0_1(); // U
        soln.push(0);
        nodes++;
        if(search_move_0_1(depth-1)) s = true; // U
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(1);
        nodes++;
        if(search_move_0_2(depth-1)) s = true; // U2
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(2);
        nodes++;
        if(search_move_0_3(depth-1)) s = true; // U2'
        soln.pop();
        puzzle->move_0_1(); // U
        soln.push(3);
        nodes++;
        if(search_move_0_4(depth-1)) s = true; // U'
        soln.pop();
        puzzle->move_0_1(); // U
        return s;
    }


    bool checkSolved(){
        if(puzzle->solved()){
            std::stack<int> soln2 = soln;
            std::string solution = printableMoveNames[soln2.top()];
            soln2.pop();
            while(!soln2.empty()){
                solution = printableMoveNames[soln2.top()] + " " + solution;
                soln2.pop();
            }
            std::cout << "  " << solution << "\n" << std::flush;
            numSolutions++;
            return true;
        }
        else return false;
    }

    Scramble *scramble;
    Puzzle *puzzle;
    std::stack<int> soln;
    uint64_t nodes;
    int numSolutions;
};

#endif // SOLVER_H

