/**********************************************
 * This code was generated by ksolve++ v1.0.0 *
 **********************************************/

#ifndef PRUNING_H
#define PRUNING_H

#include <vector>
#include <map>
#include <fstream>
#include <string.h>
#include <algorithm>
#include "puzzle.h"

char tableDepths[3];

char *EDGES_p_table = new char[362880];
void make_EDGES_p_table(){
    Puzzle p;
    char depth = 0;
    uint64_t h;
    memset(EDGES_p_table, -1, 362880);
    time_t t = clock();
    EDGES_p_table[p.encode_EDGES_p()] = 0;
    uint64_t newPositions = 1, totalPositions = 1;
    std::cout << "Generating complete pruning table \"EDGES_p_table\"\n" << std::flush;
    std::cout << "Depth\tNew\tTotal\n0\t1\t1\n" << std::flush;
    while(newPositions != 0){
        newPositions = 0;
        for(uint64_t pos=0; pos<362880; pos++){
            if(EDGES_p_table[pos] != depth) continue;
            p.decode_EDGES_p(pos);
            p.move_0_1();
            h = p.encode_EDGES_p();
            if(EDGES_p_table[h] == -1){
                EDGES_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            h = p.encode_EDGES_p();
            if(EDGES_p_table[h] == -1){
                EDGES_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            h = p.encode_EDGES_p();
            if(EDGES_p_table[h] == -1){
                EDGES_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            h = p.encode_EDGES_p();
            if(EDGES_p_table[h] == -1){
                EDGES_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            p.move_1_1();
            h = p.encode_EDGES_p();
            if(EDGES_p_table[h] == -1){
                EDGES_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_1_1();
            h = p.encode_EDGES_p();
            if(EDGES_p_table[h] == -1){
                EDGES_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_1_1();
            h = p.encode_EDGES_p();
            if(EDGES_p_table[h] == -1){
                EDGES_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_1_1();
            h = p.encode_EDGES_p();
            if(EDGES_p_table[h] == -1){
                EDGES_p_table[h] = depth + 1;
                newPositions++;
            }
        }
        depth++;
        totalPositions += newPositions;
        std::cout << (int)depth << "\t" << newPositions << "\t" << totalPositions << "\n" << std::flush;
    }
    tableDepths[0] = depth;

    std::cout << "\nTable generation finished (" << ((float)(clock()-t))/CLOCKS_PER_SEC << "s)\n" << std::flush;

    t = clock();
    FILE *f = fopen("EDGES_p.table", "wb");
    fwrite(EDGES_p_table, 1, 362880, f);
    fclose(f);

    std::cout << "Table saved (" << ((float)(clock()-t))/CLOCKS_PER_SEC << "s)\n\n" << std::flush;
}

char *CORNERS_p_table = new char[40320];
void make_CORNERS_p_table(){
    Puzzle p;
    char depth = 0;
    uint64_t h;
    memset(CORNERS_p_table, -1, 40320);
    time_t t = clock();
    CORNERS_p_table[p.encode_CORNERS_p()] = 0;
    uint64_t newPositions = 1, totalPositions = 1;
    std::cout << "Generating complete pruning table \"CORNERS_p_table\"\n" << std::flush;
    std::cout << "Depth\tNew\tTotal\n0\t1\t1\n" << std::flush;
    while(newPositions != 0){
        newPositions = 0;
        for(uint64_t pos=0; pos<40320; pos++){
            if(CORNERS_p_table[pos] != depth) continue;
            p.decode_CORNERS_p(pos);
            p.move_0_1();
            h = p.encode_CORNERS_p();
            if(CORNERS_p_table[h] == -1){
                CORNERS_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            h = p.encode_CORNERS_p();
            if(CORNERS_p_table[h] == -1){
                CORNERS_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            h = p.encode_CORNERS_p();
            if(CORNERS_p_table[h] == -1){
                CORNERS_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            h = p.encode_CORNERS_p();
            if(CORNERS_p_table[h] == -1){
                CORNERS_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            p.move_1_1();
            h = p.encode_CORNERS_p();
            if(CORNERS_p_table[h] == -1){
                CORNERS_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_1_1();
            h = p.encode_CORNERS_p();
            if(CORNERS_p_table[h] == -1){
                CORNERS_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_1_1();
            h = p.encode_CORNERS_p();
            if(CORNERS_p_table[h] == -1){
                CORNERS_p_table[h] = depth + 1;
                newPositions++;
            }
            p.move_1_1();
            h = p.encode_CORNERS_p();
            if(CORNERS_p_table[h] == -1){
                CORNERS_p_table[h] = depth + 1;
                newPositions++;
            }
        }
        depth++;
        totalPositions += newPositions;
        std::cout << (int)depth << "\t" << newPositions << "\t" << totalPositions << "\n" << std::flush;
    }
    tableDepths[1] = depth;

    std::cout << "\nTable generation finished (" << ((float)(clock()-t))/CLOCKS_PER_SEC << "s)\n" << std::flush;

    t = clock();
    FILE *f = fopen("CORNERS_p.table", "wb");
    fwrite(CORNERS_p_table, 1, 40320, f);
    fclose(f);

    std::cout << "Table saved (" << ((float)(clock()-t))/CLOCKS_PER_SEC << "s)\n\n" << std::flush;
}

char *CORNERS_o_table = new char[2187];
void make_CORNERS_o_table(){
    Puzzle p;
    char depth = 0;
    uint64_t h;
    memset(CORNERS_o_table, -1, 2187);
    time_t t = clock();
    CORNERS_o_table[p.encode_CORNERS_o()] = 0;
    uint64_t newPositions = 1, totalPositions = 1;
    std::cout << "Generating complete pruning table \"CORNERS_o_table\"\n" << std::flush;
    std::cout << "Depth\tNew\tTotal\n0\t1\t1\n" << std::flush;
    while(newPositions != 0){
        newPositions = 0;
        for(uint64_t pos=0; pos<2187; pos++){
            if(CORNERS_o_table[pos] != depth) continue;
            p.decode_CORNERS_o(pos);
            p.move_0_1();
            h = p.encode_CORNERS_o();
            if(CORNERS_o_table[h] == -1){
                CORNERS_o_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            h = p.encode_CORNERS_o();
            if(CORNERS_o_table[h] == -1){
                CORNERS_o_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            h = p.encode_CORNERS_o();
            if(CORNERS_o_table[h] == -1){
                CORNERS_o_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            h = p.encode_CORNERS_o();
            if(CORNERS_o_table[h] == -1){
                CORNERS_o_table[h] = depth + 1;
                newPositions++;
            }
            p.move_0_1();
            p.move_1_1();
            h = p.encode_CORNERS_o();
            if(CORNERS_o_table[h] == -1){
                CORNERS_o_table[h] = depth + 1;
                newPositions++;
            }
            p.move_1_1();
            h = p.encode_CORNERS_o();
            if(CORNERS_o_table[h] == -1){
                CORNERS_o_table[h] = depth + 1;
                newPositions++;
            }
            p.move_1_1();
            h = p.encode_CORNERS_o();
            if(CORNERS_o_table[h] == -1){
                CORNERS_o_table[h] = depth + 1;
                newPositions++;
            }
            p.move_1_1();
            h = p.encode_CORNERS_o();
            if(CORNERS_o_table[h] == -1){
                CORNERS_o_table[h] = depth + 1;
                newPositions++;
            }
        }
        depth++;
        totalPositions += newPositions;
        std::cout << (int)depth << "\t" << newPositions << "\t" << totalPositions << "\n" << std::flush;
    }
    tableDepths[2] = depth;

    std::cout << "\nTable generation finished (" << ((float)(clock()-t))/CLOCKS_PER_SEC << "s)\n" << std::flush;

    t = clock();
    FILE *f = fopen("CORNERS_o.table", "wb");
    fwrite(CORNERS_o_table, 1, 2187, f);
    fclose(f);

    std::cout << "Table saved (" << ((float)(clock()-t))/CLOCKS_PER_SEC << "s)\n\n" << std::flush;
}


void loadPruningTables(){
    FILE *f;
    f = fopen("EDGES_p.table", "rb");
    if(f == NULL){
        make_EDGES_p_table();
    }
    else{
        fread(EDGES_p_table, 1, 362880, f);
        fclose(f);
    }
    f = fopen("CORNERS_p.table", "rb");
    if(f == NULL){
        make_CORNERS_p_table();
    }
    else{
        fread(CORNERS_p_table, 1, 40320, f);
        fclose(f);
    }
    f = fopen("CORNERS_o.table", "rb");
    if(f == NULL){
        make_CORNERS_o_table();
    }
    else{
        fread(CORNERS_o_table, 1, 2187, f);
        fclose(f);
    }
}

bool prune(Puzzle *p, int depth){
    uint64_t h;
    if(EDGES_p_table[p->encode_EDGES_p()] > depth) return true;
    if(CORNERS_p_table[p->encode_CORNERS_p()] > depth) return true;
    if(CORNERS_o_table[p->encode_CORNERS_o()] > depth) return true;
    return false;
}

#endif // PRUNING_H
